<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screenshot Plus OCR Extension - Unit Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        .test-controls {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-output {
            background: #1e1e1e;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            min-height: 400px;
            overflow-y: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        .button:hover {
            background-color: #45a049;
        }
        .test-summary {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #4CAF50;
        }
        .test-summary.failed {
            border-left-color: #f44336;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ðŸ§ª Screenshot Plus OCR Extension - Unit Tests</h1>
        <p>Simple test runner with immediate execution</p>
    </div>

    <div class="test-controls">
        <button id="runTests" class="button">Run All Tests</button>
        <button id="clearOutput" class="button">Clear Output</button>
    </div>

    <div id="testSummary" class="test-summary" style="display: none;">
        <div id="summaryContent"></div>
    </div>

    <div class="test-output" id="testOutput">
        Click "Run All Tests" to start testing...
    </div>

    <!-- Load modules first -->
    <script src="../modules/storage-manager.js"></script>
    <script src="../modules/clipboard-manager.js"></script>
    <script src="../modules/ocr-service.js"></script>
    <script src="../modules/screenshot-capture.js"></script>
    <script src="../modules/ui-manager.js"></script>
    
    <!-- Load content script modules -->
    <script src="../content-modules/area-capture.js"></script>
    <script src="../content-modules/image-cropper.js"></script>

    <script>
        // Simple test framework
        class SimpleTestFramework {
            constructor() {
                this.results = { passed: 0, failed: 0, total: 0 };
                this.output = [];
            }

            reset() {
                this.results = { passed: 0, failed: 0, total: 0 };
                this.output = [];
            }

            log(message, type = 'log') {
                this.output.push({ message, type });
                console.log(message);
            }

            describe(name, fn) {
                this.log(`\nðŸ§ª Test Suite: ${name}`, 'group');
                fn();
            }

            it(description, fn) {
                try {
                    fn();
                    this.results.passed++;
                    this.log(`âœ… ${description}`);
                } catch (error) {
                    this.results.failed++;
                    this.log(`âŒ ${description}`);
                    this.log(`   Error: ${error.message}`, 'error');
                }
                this.results.total++;
            }

            async itAsync(description, fn) {
                try {
                    await fn();
                    this.results.passed++;
                    this.log(`âœ… ${description}`);
                } catch (error) {
                    this.results.failed++;
                    this.log(`âŒ ${description}`);
                    this.log(`   Error: ${error.message}`, 'error');
                }
                this.results.total++;
            }

            expect(actual) {
                return {
                    toBe: (expected) => {
                        if (actual !== expected) {
                            throw new Error(`Expected ${expected}, but got ${actual}`);
                        }
                    },
                    toEqual: (expected) => {
                        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                            throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
                        }
                    },
                    toBeTruthy: () => {
                        if (!actual) {
                            throw new Error(`Expected truthy value, but got ${actual}`);
                        }
                    },
                    toBeFalsy: () => {
                        if (actual) {
                            throw new Error(`Expected falsy value, but got ${actual}`);
                        }
                    },
                    toThrow: () => {
                        if (typeof actual !== 'function') {
                            throw new Error('Expected a function for toThrow assertion');
                        }
                        try {
                            actual();
                            throw new Error('Expected function to throw, but it didn\'t');
                        } catch (e) {
                            // Function threw as expected
                        }
                    },
                    toContain: (expected) => {
                        if (!actual.includes(expected)) {
                            throw new Error(`Expected ${actual} to contain ${expected}`);
                        }
                    },
                    toBeInstanceOf: (constructor) => {
                        if (!(actual instanceof constructor)) {
                            throw new Error(`Expected instance of ${constructor.name}, but got ${typeof actual}`);
                        }
                    },
                    toBeNull: () => {
                        if (actual !== null) {
                            throw new Error(`Expected null, but got ${actual}`);
                        }
                    },
                    toBeUndefined: () => {
                        if (actual !== undefined) {
                            throw new Error(`Expected undefined, but got ${actual}`);
                        }
                    },
                    toHaveProperty: (property) => {
                        if (!(property in actual)) {
                            throw new Error(`Expected object to have property ${property}`);
                        }
                    }
                };
            }

            createMock(implementation = () => {}) {
                const mock = function(...args) {
                    mock.calls.push(args);
                    mock.callCount++;
                    return implementation.apply(this, args);
                };
                
                mock.calls = [];
                mock.callCount = 0;
                mock.mockReturnValue = (value) => {
                    implementation = () => value;
                    return mock;
                };
                mock.mockResolvedValue = (value) => {
                    implementation = () => Promise.resolve(value);
                    return mock;
                };
                mock.mockRejectedValue = (error) => {
                    implementation = () => Promise.reject(error);
                    return mock;
                };
                mock.mockImplementation = (fn) => {
                    implementation = fn;
                    return mock;
                };
                
                return mock;
            }

            // DOM Mocking utilities for content script testing
            createMockElement(tagName, properties = {}) {
                const element = {
                    tagName: tagName.toUpperCase(),
                    style: {},
                    classList: {
                        add: this.createMock(),
                        remove: this.createMock(),
                        contains: this.createMock(() => false),
                        toggle: this.createMock()
                    },
                    addEventListener: this.createMock(),
                    removeEventListener: this.createMock(),
                    appendChild: this.createMock(),
                    removeChild: this.createMock(),
                    remove: this.createMock(),
                    getBoundingClientRect: this.createMock(() => ({
                        left: 0, top: 0, right: 100, bottom: 100, width: 100, height: 100
                    })),
                    setAttribute: this.createMock(),
                    getAttribute: this.createMock(),
                    focus: this.createMock(),
                    blur: this.createMock(),
                    ...properties
                };
                
                // Mock canvas-specific methods if it's a canvas element
                if (tagName.toLowerCase() === 'canvas') {
                    element.getContext = this.createMock(() => this.createMockCanvasContext());
                    element.toDataURL = this.createMock(() => 'data:image/png;base64,mockdata');
                    element.width = 100;
                    element.height = 100;
                }
                
                return element;
            }

            createMockCanvasContext() {
                return {
                    drawImage: this.createMock(),
                    clearRect: this.createMock(),
                    fillRect: this.createMock(),
                    strokeRect: this.createMock(),
                    save: this.createMock(),
                    restore: this.createMock(),
                    translate: this.createMock(),
                    scale: this.createMock(),
                    fillStyle: '#000000',
                    strokeStyle: '#000000',
                    lineWidth: 1,
                    canvas: { width: 100, height: 100 }
                };
            }

            mockDocument() {
                return {
                    createElement: this.createMock((tagName) => this.createMockElement(tagName)),
                    getElementById: this.createMock(() => null),
                    querySelector: this.createMock(() => null),
                    querySelectorAll: this.createMock(() => []),
                    body: this.createMockElement('body'),
                    documentElement: this.createMockElement('html'),
                    addEventListener: this.createMock(),
                    removeEventListener: this.createMock()
                };
            }

            mockWindow() {
                return {
                    addEventListener: this.createMock(),
                    removeEventListener: this.createMock(),
                    getComputedStyle: this.createMock(() => ({})),
                    innerWidth: 1920,
                    innerHeight: 1080,
                    pageXOffset: 0,
                    pageYOffset: 0,
                    Image: this.createMock(function() {
                        const img = {
                            onload: null,
                            onerror: null,
                            src: '',
                            width: 100,
                            height: 100,
                            complete: false
                        };
                        // Simulate async image loading
                        setTimeout(() => {
                            img.complete = true;
                            if (img.onload) img.onload();
                        }, 0);
                        return img;
                    })
                };
            }

            createMouseEvent(type, properties = {}) {
                return {
                    type,
                    clientX: 0,
                    clientY: 0,
                    pageX: 0,
                    pageY: 0,
                    button: 0,
                    buttons: 1,
                    preventDefault: this.createMock(),
                    stopPropagation: this.createMock(),
                    ...properties
                };
            }

            createKeyboardEvent(type, properties = {}) {
                return {
                    type,
                    key: '',
                    code: '',
                    keyCode: 0,
                    preventDefault: this.createMock(),
                    stopPropagation: this.createMock(),
                    ...properties
                };
            }

            printResults() {
                this.log('\nðŸ“Š Test Results Summary:');
                this.log(`Total tests: ${this.results.total}`);
                this.log(`âœ… Passed: ${this.results.passed}`);
                this.log(`âŒ Failed: ${this.results.failed}`);
                
                if (this.results.failed === 0) {
                    this.log('ðŸŽ‰ All tests passed!');
                } else {
                    this.log(`âš ï¸  ${this.results.failed} test(s) failed`);
                }
                
                return this.results.failed === 0;
            }
        }

        // Global test framework instance
        const testFramework = new SimpleTestFramework();
        
        // Export globally
        window.describe = (name, fn) => testFramework.describe(name, fn);
        window.it = (description, fn) => testFramework.it(description, fn);
        window.itAsync = (description, fn) => testFramework.itAsync(description, fn);
        window.expect = (actual) => testFramework.expect(actual);
        window.createMock = (impl) => testFramework.createMock(impl);
        window.createMockElement = (tagName, props) => testFramework.createMockElement(tagName, props);
        window.mockDocument = () => testFramework.mockDocument();
        window.mockWindow = () => testFramework.mockWindow();
        window.createMouseEvent = (type, props) => testFramework.createMouseEvent(type, props);
        window.createKeyboardEvent = (type, props) => testFramework.createKeyboardEvent(type, props);

        // Test runner
        class TestRunner {
            constructor() {
                this.outputElement = document.getElementById('testOutput');
                this.summaryElement = document.getElementById('testSummary');
                this.summaryContent = document.getElementById('summaryContent');
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.getElementById('runTests').addEventListener('click', () => this.runAllTests());
                document.getElementById('clearOutput').addEventListener('click', () => this.clearOutput());
            }

            async runAllTests() {
                this.clearOutput();
                testFramework.reset();
                
                this.addOutput('ðŸš€ Starting test execution...\n', 'info');
                
                try {
                    // Run basic tests to verify framework
                    this.runBasicTests();
                    
                    // Run module tests
                    await this.runModuleTests();
                    
                    const allPassed = testFramework.printResults();
                    this.showSummary(testFramework.results, allPassed);
                    
                } catch (error) {
                    this.addOutput(`Test execution failed: ${error.message}`, 'error');
                }
            }

            runBasicTests() {
                describe('Basic Framework Tests', () => {
                    it('should have modules loaded', () => {
                        expect(typeof ClipboardManager).toBe('function');
                        expect(typeof OCRService).toBe('function');
                        expect(typeof StorageManager).toBe('function');
                        expect(typeof UIManager).toBe('function');
                        expect(typeof ScreenshotCapture).toBe('function');
                        expect(typeof AreaCapture).toBe('function');
                        expect(typeof ImageCropper).toBe('function');
                    });

                    it('should create module instances', () => {
                        const clipboard = new ClipboardManager();
                        const ocr = new OCRService();
                        const storage = new StorageManager();
                        const ui = new UIManager();
                        const screenshot = new ScreenshotCapture();
                        const areaCapture = new AreaCapture(testFramework.mockDocument());
                        const imageCropper = new ImageCropper(testFramework.mockDocument(), testFramework.mockWindow());
                        
                        expect(clipboard).toBeInstanceOf(ClipboardManager);
                        expect(ocr).toBeInstanceOf(OCRService);
                        expect(storage).toBeInstanceOf(StorageManager);
                        expect(ui).toBeInstanceOf(UIManager);
                        expect(screenshot).toBeInstanceOf(ScreenshotCapture);
                        expect(areaCapture).toBeInstanceOf(AreaCapture);
                        expect(imageCropper).toBeInstanceOf(ImageCropper);
                    });
                });
            }

            async runModuleTests() {
                // ClipboardManager tests
                describe('ClipboardManager', () => {
                    it('should initialize with correct properties', () => {
                        const manager = new ClipboardManager();
                        expect(manager).toHaveProperty('isSupported');
                    });

                    it('should convert data URL to blob', () => {
                        const manager = new ClipboardManager();
                        const testDataURL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
                        const blob = manager.dataURLToBlob(testDataURL);
                        expect(blob).toBeInstanceOf(Blob);
                        expect(blob.type).toBe('image/png');
                    });
                });

                // OCRService tests
                describe('OCRService', () => {
                    it('should initialize with default values', () => {
                        const service = new OCRService();
                        expect(service.baseURL).toBe('https://openrouter.ai/api/v1/chat/completions');
                        expect(service.defaultModel).toBe('openai/gpt-4o');
                        expect(service.maxTokens).toBe(4000);
                    });

                    it('should validate supported models', () => {
                        const service = new OCRService();
                        expect(service.isValidModel('openai/gpt-4o')).toBeTruthy();
                        expect(service.isValidModel('invalid/model')).toBeFalsy();
                    });

                    it('should return supported models list', () => {
                        const service = new OCRService();
                        const models = service.getSupportedModels();
                        expect(models).toBeInstanceOf(Array);
                        expect(models.length).toBe(6);
                    });
                });

                // StorageManager tests
                describe('StorageManager', () => {
                    it('should initialize with correct properties', () => {
                        const manager = new StorageManager();
                        expect(manager.syncKeys).toEqual(['apiKey', 'selectedModel']);
                        expect(manager.localKeys).toEqual(['latestScreenshot', 'screenshotTimestamp']);
                        expect(manager.screenshotExpiryTime).toBe(5 * 60 * 1000);
                    });
                });

                // UIManager tests
                describe('UIManager', () => {
                    it('should initialize with default state', () => {
                        const manager = new UIManager();
                        expect(manager.elements).toEqual({});
                        expect(manager.state).toEqual({
                            isCapturing: false,
                            hasScreenshot: false,
                            isProcessing: false
                        });
                        expect(manager.callbacks).toEqual({});
                    });

                    it('should handle event registration', () => {
                        const manager = new UIManager();
                        const callback = createMock();
                        manager.on('testEvent', callback);
                        manager.emit('testEvent', 'testData');
                        expect(callback.callCount).toBe(1);
                        expect(callback.calls[0][0]).toBe('testData');
                    });
                });

                // ScreenshotCapture tests
                describe('ScreenshotCapture', () => {
                    let capture;
                    let mockChrome;
                    let originalChrome;

                    const beforeEach = () => {
                        capture = new ScreenshotCapture();
                        
                        // Mock Chrome APIs
                        mockChrome = {
                            runtime: {
                                sendMessage: createMock(),
                                lastError: null,
                                onMessage: {
                                    addListener: createMock()
                                }
                            },
                            tabs: {
                                query: createMock(),
                                sendMessage: createMock(),
                                captureVisibleTab: createMock()
                            },
                            scripting: {
                                executeScript: createMock()
                            }
                        };
                        
                        originalChrome = window.chrome;
                        window.chrome = mockChrome;
                    };

                    const afterEach = () => {
                        if (originalChrome) {
                            window.chrome = originalChrome;
                        } else {
                            delete window.chrome;
                        }
                        
                        if (capture.isCapturing) {
                            capture.cancelCapture();
                        }
                    };

                    it('should initialize with default state', () => {
                        beforeEach();
                        
                        expect(capture.isCapturing).toBeFalsy();
                        expect(capture.currentCallback).toBeNull();
                        
                        afterEach();
                    });

                    it('should handle full page capture successfully', async () => {
                        beforeEach();
                        
                        // Mock successful response
                        mockChrome.runtime.sendMessage.implementation = (message, callback) => {
                            setTimeout(() => {
                                callback({ imageData: 'data:image/png;base64,test' });
                            }, 0);
                        };
                        
                        const result = await capture.captureFullPage();
                        expect(result).toBe('data:image/png;base64,test');
                        expect(mockChrome.runtime.sendMessage.callCount).toBe(1);
                        
                        afterEach();
                    });

                    it('should handle full page capture errors', async () => {
                        beforeEach();
                        
                        // Mock error response
                        mockChrome.runtime.sendMessage.implementation = (message, callback) => {
                            setTimeout(() => {
                                callback({ error: 'Capture failed' });
                            }, 0);
                        };
                        
                        let error;
                        try {
                            await capture.captureFullPage();
                        } catch (e) {
                            error = e;
                        }
                        
                        expect(error).toBeDefined();
                        expect(error.message).toBe('Capture failed');
                        
                        afterEach();
                    });

                    it('should handle runtime errors in full page capture', async () => {
                        beforeEach();
                        
                        // Mock runtime error
                        mockChrome.runtime.sendMessage.implementation = (message, callback) => {
                            mockChrome.runtime.lastError = { message: 'Runtime error' };
                            setTimeout(() => callback(), 0);
                        };
                        
                        let error;
                        try {
                            await capture.captureFullPage();
                        } catch (e) {
                            error = e;
                        }
                        
                        expect(error).toBeDefined();
                        expect(error.message).toBe('Runtime error');
                        
                        afterEach();
                    });

                    it('should start area capture successfully', async () => {
                        beforeEach();
                        
                        // Mock successful tab query and script injection
                        mockChrome.tabs.query.implementation = (query, callback) => {
                            setTimeout(() => {
                                callback([{ id: 1, url: 'https://example.com' }]);
                            }, 0);
                        };
                        
                        mockChrome.scripting.executeScript.implementation = (options, callback) => {
                            setTimeout(() => callback(), 0);
                        };
                        
                        mockChrome.tabs.sendMessage.implementation = (tabId, message, callback) => {
                            setTimeout(() => {
                                callback({ success: true });
                            }, 0);
                        };
                        
                        const capturePromise = capture.captureArea();
                        
                        // Should be in capturing state
                        expect(capture.isCapturing).toBeTruthy();
                        expect(capture.currentCallback).toBeDefined();
                        
                        // Wait for area capture to start
                        await new Promise(resolve => setTimeout(resolve, 10));
                        
                        expect(mockChrome.tabs.query.callCount).toBe(1);
                        expect(mockChrome.scripting.executeScript.callCount).toBe(1);
                        expect(mockChrome.tabs.sendMessage.callCount).toBe(1);
                        
                        afterEach();
                    });

                    it('should reject area capture when already capturing', async () => {
                        beforeEach();
                        
                        capture.isCapturing = true;
                        
                        let error;
                        try {
                            await capture.captureArea();
                        } catch (e) {
                            error = e;
                        }
                        
                        expect(error).toBeDefined();
                        expect(error.message).toBe('Already capturing');
                        
                        afterEach();
                    });

                    it('should handle no active tab error', async () => {
                        beforeEach();
                        
                        // Mock empty tab query
                        mockChrome.tabs.query.implementation = (query, callback) => {
                            setTimeout(() => {
                                callback([]);
                            }, 0);
                        };
                        
                        let error;
                        try {
                            await capture.captureArea();
                        } catch (e) {
                            error = e;
                        }
                        
                        expect(error).toBeDefined();
                        expect(error.message).toBe('No active tab');
                        
                        afterEach();
                    });

                    it('should handle content script communication error', async () => {
                        beforeEach();
                        
                        // Mock successful tab query and script injection
                        mockChrome.tabs.query.implementation = (query, callback) => {
                            setTimeout(() => {
                                callback([{ id: 1, url: 'https://example.com' }]);
                            }, 0);
                        };
                        
                        mockChrome.scripting.executeScript.implementation = (options, callback) => {
                            setTimeout(() => callback(), 0);
                        };
                        
                        // Mock communication error
                        mockChrome.tabs.sendMessage.implementation = (tabId, message, callback) => {
                            mockChrome.runtime.lastError = { message: 'No response' };
                            setTimeout(() => callback(), 0);
                        };
                        
                        let error;
                        try {
                            await capture.captureArea();
                        } catch (e) {
                            error = e;
                        }
                        
                        expect(error).toBeDefined();
                        expect(error.message).toBe('Cannot start area capture on this page. Try refreshing the page.');
                        
                        afterEach();
                    });

                    it('should handle area capture completion', () => {
                        beforeEach();
                        
                        const mockCallback = createMock();
                        capture.currentCallback = { resolve: mockCallback, reject: createMock() };
                        capture.isCapturing = true;
                        
                        const testImageData = 'data:image/png;base64,test';
                        capture.handleAreaCaptureComplete(testImageData);
                        
                        expect(capture.isCapturing).toBeFalsy();
                        expect(capture.currentCallback).toBeNull();
                        expect(mockCallback.callCount).toBe(1);
                        expect(mockCallback.calls[0][0]).toBe(testImageData);
                        
                        afterEach();
                    });

                    it('should handle area capture error', () => {
                        beforeEach();
                        
                        const mockCallback = createMock();
                        capture.currentCallback = { resolve: createMock(), reject: mockCallback };
                        capture.isCapturing = true;
                        
                        const testError = new Error('Test error');
                        capture.handleAreaCaptureError(testError);
                        
                        expect(capture.isCapturing).toBeFalsy();
                        expect(capture.currentCallback).toBeNull();
                        expect(mockCallback.callCount).toBe(1);
                        expect(mockCallback.calls[0][0]).toBe(testError);
                        
                        afterEach();
                    });

                    it('should cancel capture operation', () => {
                        beforeEach();
                        
                        const mockCallback = createMock();
                        capture.currentCallback = { resolve: createMock(), reject: mockCallback };
                        capture.isCapturing = true;
                        
                        capture.cancelCapture();
                        
                        expect(capture.isCapturing).toBeFalsy();
                        expect(capture.currentCallback).toBeNull();
                        expect(mockCallback.callCount).toBe(1);
                        expect(mockCallback.calls[0][0].message).toBe('Capture cancelled');
                        
                        afterEach();
                    });

                    it('should handle completion without callback', () => {
                        beforeEach();
                        
                        capture.isCapturing = true;
                        capture.currentCallback = null;
                        
                        // Should not throw error
                        capture.handleAreaCaptureComplete('test');
                        expect(capture.isCapturing).toBeFalsy();
                        
                        afterEach();
                    });

                    it('should handle error without callback', () => {
                        beforeEach();
                        
                        capture.isCapturing = true;
                        capture.currentCallback = null;
                        
                        // Should not throw error
                        capture.handleAreaCaptureError(new Error('Test'));
                        expect(capture.isCapturing).toBeFalsy();
                        
                        afterEach();
                    });

                    it('should handle cancel when not capturing', () => {
                        beforeEach();
                        
                        capture.isCapturing = false;
                        
                        // Should not throw error
                        capture.cancelCapture();
                        expect(capture.isCapturing).toBeFalsy();
                        
                        afterEach();
                    });
                });

                // AreaCapture tests
                describe('AreaCapture', () => {
                    let areaCapture;
                    let mockDocument;
                    let originalDocument;

                    // Setup before each test
                    const beforeEach = () => {
                        mockDocument = testFramework.mockDocument();
                        originalDocument = document;
                        
                        // Pass mock document to AreaCapture constructor
                        areaCapture = new AreaCapture(mockDocument);
                    };

                    // Cleanup after each test
                    const afterEach = () => {
                        if (areaCapture.isActive) {
                            areaCapture.stop();
                        }
                    };

                    it('should initialize with correct default state', () => {
                        beforeEach();
                        
                        const state = areaCapture.getState();
                        expect(state.isActive).toBeFalsy();
                        expect(state.isDrawing).toBeFalsy();
                        expect(state.hasOverlay).toBeFalsy();
                        expect(state.hasSelectionBox).toBeFalsy();
                        expect(state.coordinates.startX).toBe(0);
                        expect(state.coordinates.startY).toBe(0);
                        
                        afterEach();
                    });

                    it('should start area capture successfully', () => {
                        beforeEach();
                        
                        const onComplete = createMock();
                        const onCancel = createMock();
                        
                        areaCapture.start(onComplete, onCancel);
                        
                        const state = areaCapture.getState();
                        expect(state.isActive).toBeTruthy();
                        expect(areaCapture.onCompleteCallback).toBe(onComplete);
                        expect(areaCapture.onCancelCallback).toBe(onCancel);
                        expect(mockDocument.createElement.callCount).toBe(3); // overlay, selection, instructions
                        
                        afterEach();
                    });

                    it('should throw error when starting while already active', () => {
                        beforeEach();
                        
                        areaCapture.start(createMock(), createMock());
                        
                        expect(() => {
                            areaCapture.start(createMock(), createMock());
                        }).toThrow('Area capture is already active');
                        
                        afterEach();
                    });

                    it('should handle mouse down event correctly', () => {
                        beforeEach();
                        
                        areaCapture.start(createMock(), createMock());
                        
                        const mouseEvent = createMouseEvent('mousedown', {
                            clientX: 100,
                            clientY: 200
                        });
                        
                        areaCapture.handleMouseDown(mouseEvent);
                        
                        const state = areaCapture.getState();
                        expect(state.isDrawing).toBeTruthy();
                        expect(state.coordinates.startX).toBe(100);
                        expect(state.coordinates.startY).toBe(200);
                        expect(mouseEvent.preventDefault.callCount).toBe(1);
                        
                        afterEach();
                    });

                    it('should handle mouse move during drawing', () => {
                        beforeEach();
                        
                        areaCapture.start(createMock(), createMock());
                        areaCapture.isDrawing = true;
                        areaCapture.startX = 50;
                        areaCapture.startY = 75;
                        
                        const mouseEvent = createMouseEvent('mousemove', {
                            clientX: 150,
                            clientY: 175
                        });
                        
                        areaCapture.handleMouseMove(mouseEvent);
                        
                        const state = areaCapture.getState();
                        expect(state.coordinates.endX).toBe(150);
                        expect(state.coordinates.endY).toBe(175);
                        
                        afterEach();
                    });

                    it('should calculate selected area correctly', () => {
                        beforeEach();
                        
                        areaCapture.startX = 50;
                        areaCapture.startY = 100;
                        areaCapture.endX = 200;
                        areaCapture.endY = 300;
                        
                        const area = areaCapture.getSelectedArea();
                        
                        expect(area.x).toBe(50);
                        expect(area.y).toBe(100);
                        expect(area.width).toBe(150);
                        expect(area.height).toBe(200);
                        
                        afterEach();
                    });

                    it('should handle reverse selection (drag from bottom-right to top-left)', () => {
                        beforeEach();
                        
                        areaCapture.startX = 200;
                        areaCapture.startY = 300;
                        areaCapture.endX = 50;
                        areaCapture.endY = 100;
                        
                        const area = areaCapture.getSelectedArea();
                        
                        expect(area.x).toBe(50);
                        expect(area.y).toBe(100);
                        expect(area.width).toBe(150);
                        expect(area.height).toBe(200);
                        
                        afterEach();
                    });

                    it('should reject small selections', () => {
                        beforeEach();
                        
                        const onComplete = createMock();
                        areaCapture.start(onComplete, createMock());
                        areaCapture.isDrawing = true;
                        areaCapture.startX = 100;
                        areaCapture.startY = 100;
                        areaCapture.endX = 105; // Only 5px wide
                        areaCapture.endY = 105; // Only 5px tall
                        
                        const mouseEvent = createMouseEvent('mouseup');
                        areaCapture.handleMouseUp(mouseEvent);
                        
                        expect(onComplete.callCount).toBe(0); // Should not complete
                        expect(areaCapture.isDrawing).toBeFalsy();
                        
                        afterEach();
                    });

                    it('should complete selection for valid area', () => {
                        beforeEach();
                        
                        const onComplete = createMock();
                        areaCapture.start(onComplete, createMock());
                        areaCapture.isDrawing = true;
                        areaCapture.startX = 100;
                        areaCapture.startY = 100;
                        areaCapture.endX = 200;
                        areaCapture.endY = 200;
                        
                        const mouseEvent = createMouseEvent('mouseup');
                        areaCapture.handleMouseUp(mouseEvent);
                        
                        expect(onComplete.callCount).toBe(1);
                        const area = onComplete.calls[0][0];
                        expect(area.width).toBe(100);
                        expect(area.height).toBe(100);
                        
                        afterEach();
                    });

                    it('should handle ESC key cancellation', () => {
                        beforeEach();
                        
                        const onCancel = createMock();
                        areaCapture.start(createMock(), onCancel);
                        
                        const keyEvent = createKeyboardEvent('keydown', { key: 'Escape' });
                        areaCapture.handleKeyDown(keyEvent);
                        
                        expect(onCancel.callCount).toBe(1);
                        expect(keyEvent.preventDefault.callCount).toBe(1);
                        expect(areaCapture.isActive).toBeFalsy();
                        
                        afterEach();
                    });

                    it('should ignore non-ESC keys', () => {
                        beforeEach();
                        
                        const onCancel = createMock();
                        areaCapture.start(createMock(), onCancel);
                        
                        const keyEvent = createKeyboardEvent('keydown', { key: 'Enter' });
                        areaCapture.handleKeyDown(keyEvent);
                        
                        expect(onCancel.callCount).toBe(0);
                        expect(areaCapture.isActive).toBeTruthy();
                        
                        afterEach();
                    });

                    it('should stop capture and cleanup properly', () => {
                        beforeEach();
                        
                        areaCapture.start(createMock(), createMock());
                        expect(areaCapture.isActive).toBeTruthy();
                        
                        areaCapture.stop();
                        
                        const state = areaCapture.getState();
                        expect(state.isActive).toBeFalsy();
                        expect(state.isDrawing).toBeFalsy();
                        expect(state.hasOverlay).toBeFalsy();
                        expect(areaCapture.onCompleteCallback).toBeNull();
                        expect(areaCapture.onCancelCallback).toBeNull();
                        
                        afterEach();
                    });

                    it('should handle stop when not active', () => {
                        beforeEach();
                        
                        // Should not throw error
                        areaCapture.stop();
                        expect(areaCapture.isActive).toBeFalsy();
                        
                        afterEach();
                    });

                    it('should create overlay with correct structure', () => {
                        beforeEach();
                        
                        areaCapture.start(createMock(), createMock());
                        
                        // Check that elements were created
                        expect(mockDocument.createElement.callCount).toBe(3);
                        expect(mockDocument.body.appendChild.callCount).toBe(1);
                        
                        afterEach();
                    });
                });

                // ImageCropper tests
                describe('ImageCropper', () => {
                    let imageCropper;
                    let mockDocument;
                    let mockWindow;
                    const testImageData = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';

                    // Setup before each test
                    const beforeEach = () => {
                        mockDocument = testFramework.mockDocument();
                        mockWindow = testFramework.mockWindow();
                        imageCropper = new ImageCropper(mockDocument, mockWindow);
                    };

                    it('should initialize with injected dependencies', () => {
                        beforeEach();
                        
                        expect(imageCropper.doc).toBe(mockDocument);
                        expect(imageCropper.win).toBe(mockWindow);
                    });

                    it('should validate area dimensions correctly', () => {
                        beforeEach();
                        
                        // Valid area
                        expect(imageCropper.isValidArea({x: 0, y: 0, width: 100, height: 100})).toBeTruthy();
                        
                        // Invalid areas
                        expect(imageCropper.isValidArea({})).toBeFalsy();
                        expect(imageCropper.isValidArea({x: 0, y: 0})).toBeFalsy(); // missing width/height
                        expect(imageCropper.isValidArea({x: 0, y: 0, width: -10, height: 100})).toBeFalsy(); // negative width
                        expect(imageCropper.isValidArea({x: -5, y: 0, width: 100, height: 100})).toBeFalsy(); // negative x
                        expect(imageCropper.isValidArea({x: 0, y: 0, width: 0, height: 100})).toBeFalsy(); // zero width
                        expect(imageCropper.isValidArea({x: 'invalid', y: 0, width: 100, height: 100})).toBeFalsy(); // non-number
                    });

                    itAsync('should load image successfully', async () => {
                        beforeEach();
                        
                        const img = await imageCropper.loadImage(testImageData);
                        expect(img).toHaveProperty('width');
                        expect(img).toHaveProperty('height');
                        expect(img.width).toBe(100); // From mock
                        expect(img.height).toBe(100); // From mock
                    });

                    itAsync('should handle image loading failure', async () => {
                        beforeEach();
                        
                        // Mock image to fail loading
                        mockWindow.Image = createMock(function() {
                            const img = {
                                onload: null,
                                onerror: null,
                                src: ''
                            };
                            setTimeout(() => {
                                if (img.onerror) img.onerror();
                            }, 0);
                            return img;
                        });
                        
                        try {
                            await imageCropper.loadImage('invalid-data-url');
                            throw new Error('Expected function to throw');
                        } catch (error) {
                            expect(error.message).toBe('Failed to load image');
                        }
                    });

                    it('should perform crop operation with canvas', () => {
                        beforeEach();
                        
                        const mockImg = {
                            width: 200,
                            height: 200
                        };
                        const area = {x: 50, y: 50, width: 100, height: 100};
                        
                        const result = imageCropper.performCrop(mockImg, area);
                        
                        expect(mockDocument.createElement.callCount).toBe(1);
                        expect(mockDocument.createElement.calls[0][0]).toBe('canvas');
                        expect(result).toBe('data:image/png;base64,mockdata'); // From mock canvas
                    });

                    it('should reject crop area beyond image boundaries', () => {
                        beforeEach();
                        
                        const mockImg = {
                            width: 100,
                            height: 100
                        };
                        const area = {x: 50, y: 50, width: 100, height: 100}; // Extends beyond 100x100 image
                        
                        expect(() => {
                            imageCropper.performCrop(mockImg, area);
                        }).toThrow('Crop area extends beyond image boundaries');
                    });

                    itAsync('should crop image successfully', async () => {
                        beforeEach();
                        
                        const area = {x: 0, y: 0, width: 50, height: 50};
                        
                        const result = await imageCropper.cropImage(testImageData, area);
                        
                        expect(typeof result).toBe('string');
                        expect(result).toContain('data:image/png;base64,');
                    });

                    itAsync('should throw error for missing image data', async () => {
                        beforeEach();
                        
                        try {
                            await imageCropper.cropImage('', {x: 0, y: 0, width: 100, height: 100});
                            throw new Error('Expected function to throw');
                        } catch (error) {
                            expect(error.message).toBe('Image data URL is required');
                        }
                    });

                    itAsync('should throw error for invalid area', async () => {
                        beforeEach();
                        
                        try {
                            await imageCropper.cropImage(testImageData, null);
                            throw new Error('Expected function to throw');
                        } catch (error) {
                            expect(error.message).toBe('Area object is required');
                        }
                    });

                    itAsync('should get image dimensions', async () => {
                        beforeEach();
                        
                        const dimensions = await imageCropper.getImageDimensions(testImageData);
                        
                        expect(dimensions).toEqual({width: 100, height: 100});
                    });

                    itAsync('should validate crop area against image', async () => {
                        beforeEach();
                        
                        // Valid area
                        const validArea = {x: 10, y: 10, width: 50, height: 50};
                        const isValid = await imageCropper.validateCropArea(testImageData, validArea);
                        expect(isValid).toBeTruthy();
                        
                        // Invalid area (extends beyond image)
                        const invalidArea = {x: 50, y: 50, width: 100, height: 100};
                        const isInvalid = await imageCropper.validateCropArea(testImageData, invalidArea);
                        expect(isInvalid).toBeFalsy();
                    });

                    itAsync('should create crop preview', async () => {
                        beforeEach();
                        
                        const area = {x: 25, y: 25, width: 50, height: 50};
                        
                        const preview = await imageCropper.createCropPreview(testImageData, area);
                        
                        expect(typeof preview).toBe('string');
                        expect(preview).toContain('data:image/png;base64,');
                    });

                    itAsync('should perform batch crop', async () => {
                        beforeEach();
                        
                        const areas = [
                            {x: 0, y: 0, width: 25, height: 25},
                            {x: 25, y: 25, width: 25, height: 25}
                        ];
                        
                        const results = await imageCropper.batchCrop(testImageData, areas);
                        
                        expect(results).toBeInstanceOf(Array);
                        expect(results.length).toBe(2);
                        expect(typeof results[0]).toBe('string');
                        expect(typeof results[1]).toBe('string');
                    });

                    itAsync('should handle empty areas array in batch crop', async () => {
                        beforeEach();
                        
                        try {
                            await imageCropper.batchCrop(testImageData, []);
                            throw new Error('Expected function to throw');
                        } catch (error) {
                            expect(error.message).toBe('Areas array is required and must not be empty');
                        }
                    });

                    it('should get supported formats', () => {
                        beforeEach();
                        
                        const formats = imageCropper.getSupportedFormats();
                        
                        expect(formats).toBeInstanceOf(Array);
                        expect(formats.length).toBe(3); // png, jpeg, webp
                        expect(formats).toContain('image/png');
                    });

                    itAsync('should convert image format', async () => {
                        beforeEach();
                        
                        const converted = await imageCropper.convertFormat(testImageData, 'image/jpeg', 0.8);
                        
                        expect(typeof converted).toBe('string');
                        expect(converted).toContain('data:image/png;base64,'); // Mock always returns PNG
                    });
                });
            }

            addOutput(message, type = 'log') {
                const div = document.createElement('div');
                div.style.color = type === 'error' ? '#ff5555' : 
                                 type === 'info' ? '#8be9fd' : '#f8f8f2';
                div.textContent = message;
                this.outputElement.appendChild(div);
                this.outputElement.scrollTop = this.outputElement.scrollHeight;
            }

            showSummary(results, allPassed) {
                this.summaryElement.style.display = 'block';
                this.summaryElement.className = allPassed ? 'test-summary' : 'test-summary failed';
                
                const passRate = results.total > 0 ? ((results.passed / results.total) * 100).toFixed(1) : 0;
                
                this.summaryContent.innerHTML = `
                    <strong>Total:</strong> ${results.total} | 
                    <strong style="color: #4CAF50;">Passed:</strong> ${results.passed} | 
                    <strong style="color: #f44336;">Failed:</strong> ${results.failed} | 
                    <strong>Pass Rate:</strong> ${passRate}% 
                    ${allPassed ? 'âœ…' : 'âŒ'}
                `;
            }

            clearOutput() {
                this.outputElement.innerHTML = '';
                this.summaryElement.style.display = 'none';
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Redirect console to output
            const originalConsole = console.log;
            console.log = function(...args) {
                originalConsole.apply(console, args);
                const outputElement = document.getElementById('testOutput');
                if (outputElement) {
                    const div = document.createElement('div');
                    div.style.color = '#f8f8f2';
                    div.textContent = args.join(' ');
                    outputElement.appendChild(div);
                    outputElement.scrollTop = outputElement.scrollHeight;
                }
            };

            new TestRunner();
        });
    </script>
</body>
</html>